---
title: "Tractability and Turing Machines"
description: "Explore the confusion associated with Tractability and Turing Machines"
date: "2025-12-04"
date-format: long
author: Hemani Alaparthi, Hannah Brown, Cullen Doyle, Benedek Kaibas
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

## Intro Questions

::: {.fragment}
- Can a problem be intractable on a **standard** Turing Machine but tractable when solved by a Python program?
- Can a problem be intractable on a **multiple tape** Turing Machine but tractable when solved by a Python program?
- Can a problem be intractable on a **multiple read-write** Turing Machine but tractable when solved by a Python program?
:::

## Tractable and Intractable

![tractable and intractable](tractableandintractable.png){width=60%}

## What are the different types of TMs we covered in 204?

![Turing Machines](TMs.png){width=60%}

## What is tractable in terms of all types of TMs?

![Polynomial Time Complexity](Poly-Time_Expl.png)

The formula means that if `c` is a natural number and the `input size n` of the Turing Machine has a `running time TM​(n)` that is in `O(n^c)`,
then that Turing Machine has polynomial time complexity.

## Polynomial Time Factors

`For this reason we will introduce a “suped-up” version of a Turing machine, called a “multi-tape Turing 4 machine”; these machines are easier to program
and are more efficient than normal Turing machines, but their polynomial-time power is just the same as normal Turing machines.`

There are some Turing Machines that are more efficient (better time complexity), but it does not mean that their power (computability) is better.
This is what we referred to as "syntactical sugar".

## Model Equivalence

![Model Equivalence](model_equivalence.png)

All variants of Turing Machines can simulate each other with only polynomial overhead.

## Answering Our Questions

::: {.incremental}
1. **Can a problem be intractable on a standard TM but tractable in Python?**
   - **No.** Python and standard TMs are polynomially equivalent.

2. **Can a problem be intractable on a multi-tape TM but tractable in Python?**
   - **No.** Multi-tape TMs and Python are polynomially equivalent.

3. **Can a problem be intractable on a multi-read-write TM but tractable in Python?**
   - **No.** All reasonable models are polynomially equivalent.
:::

## Conclusion

::: {.incremental}
- **Tractability is an intrinsic property** of problems, not dependent on the computational model
- Different TM variants and programming languages may have different **practical efficiency**
- But they all have the **same polynomial-time power**
- A problem that's intractable on one reasonable model is intractable on all of them
- This is why we study complexity using abstract models like Turing Machines - the results apply universally
:::

## Key Takeaway

::: {.fragment style="text-align: center; font-size: 1.5em; margin-top: 2em;"}
**Tractability is about the problem, not the machine.**
:::

::: {.fragment style="text-align: center; margin-top: 2em;"}
Understanding this helps us focus on what really matters: the inherent difficulty of computational problems.
:::