---
title: "The LastTtoA Problem"
date: "2025-10-23"
date-format: long
author: Hemani Alaparthi, Benedek Kaibas, Miguel Orti Vila, Ritesh Ojha
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

::: {.fragment style="margin-top: -0.5em; font-size: 1em;"} 
- **Goal**: To implement and analyze the LastTtoA problem using multiple computation models and programming styles.
- **Problem**: Given a DNA string with symbols (e.g.,{A, C, T, G}), replace the last occurrence of 'T' with 'A'
- **Approaches**: Turing machine, Python (with/without regular expression(regex)), and another langauge.
:::


## The LastTtoA Function

::: {.fragment}
- **Input**: A string `s` that contains DNA symbols {A, C, T, G}

- **Output**: String `s'` where the last occurrence of 'T' is replaced with 'A'

**Examples**

- `ATCGT` → `ATCGA`
- `TTTT` → `TTTA` (last T becomes A)
- `ACGAA` → `ACGAA` (no T to replace)
- `T` → `A`
:::

## Implementation 1: Turing Machine

::: {.fragment style="font-size: 0.95em;"}
**Formal Components**:

- **States**: {q0, q1, qhalt}
- **Tape Alphabet**: {A, C, G, T, _}

**Two-Phase Algorithm**:

- **q0**: Scan right to find blank `_` → transition to q1
- **q1**: Scan left to find 'T' → replace with 'A' → halt

**Key Feature**: Explicit state machine matching formal TM definition
:::


## Implementation 2: Pure Python

::: {.fragment style="font-size: 0.9em;"}
**Algorithm** (No libraries, no regex):

1. **Initialize**: `last_t_index = -1`
2. **Scan forward**: Loop through entire string
   - Each time 'T' is found, update `last_t_index = i`
   - After loop completes, `last_t_index` holds position of last T
3. **Check**: If `last_t_index == -1`, no T exists → return unchanged
4. **Reconstruct**: `dna[:last_t_index] + 'A' + dna[last_t_index + 1:]`
:::

## Key Difference from TM

- Single forward pass vs. TM's two-phase scan (right then left)
- Direct string indexing vs. tape head movements
- Both achieve O(n) time complexity

## LastTtoA Turing Machine

![State Diagram](lastTtoA.png)

## LasttoA Turing Machine Implementation

## Complete Computation of the LastTtoA Machine

![Complete Computation](lastTtoA_2.png){height=50%}

## Conclusion

::: {.fragment}
**Deterministic Turing Machine**: Formal 3-state machine with transition function (q0 → q1 → qhalt, tape operations)

- Example: `ATCGT⊔` → scan right → scan left → replace T → `ATCGA`

**Pure Python**: We used Loop-based scanning with string slicing reconstruction

- Example:
```py
for i in range(len(dna)):
  if dna[i] == 'T':
    last_t_index = i
```

**Python with Regex**: Implemented pattern matching to locate and process the last 'T' and transformation to 'A'

**Non-Python Implementation**:

**Result**: All implementations produce `"ATCGT"` → `"ATCGA"` 

**Comprehensive Testing**: All implementations validated with identical test suites

**Theoretical Analysis**: LastTtoA is **computable** and **tractable** (O(n))
:::

## Key Insights

::: {.fragment}
- **Universality**: Same problem solvable across different computational models
- **Efficiency**: All approaches achieve optimal O(n) time complexity
- **Correctness**: Formal verification through comprehensive testing
:::
