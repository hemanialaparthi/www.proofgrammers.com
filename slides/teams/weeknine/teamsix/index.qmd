---
title: "The LastTtoA Problem"
date: "2025-10-23"
date-format: long
author: Hemani Alaparthi, Benedek Kaibas, Miguel Orti Vila, Ritesh Ojha
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

::: {.fragment style="margin-top: -0.5em; font-size: 1em;"} 
- **Goal**: To implement and analyze the LastTtoA problem using multiple computation models and programming styles.
- **Problem**: Given a DNA string with symbols (e.g.,{A, C, T, G}), replace the last occurrence of 'T' with 'A'
- **Approaches**: Turing machine, Python (with/without regular expression(regex)), and another langauge.
:::


## The LastTtoA Function

::: {.fragment}
- **Input**: A string `s` that contains DNA symbols {A, C, T, G}

- **Output**: String `s'` where the last occurrence of 'T' is replaced with 'A'

**Examples**

- `ATCGT` → `ATCGA`
- `TTTT` → `TTTA` (last T becomes A)
- `ACGAA` → `ACGAA` (no T to replace)
- `T` → `A`
:::

## Implementation 1: Turing Machine

::: {.fragment style="font-size: 0.95em;"}
**Formal Components**:

- **States**: {q0, q1, qhalt}
- **Tape Alphabet**: {A, C, G, T, _}

**Two-Phase Algorithm**:

- **q0**: Scan right to find blank `_` → transition to q1
- **q1**: Scan left to find 'T' → replace with 'A' → halt

**Key Feature**: Explicit state machine matching formal TM definition
:::


## Implementation 2: Pure Python

::: {.fragment style="font-size: 0.9em;"}
**Algorithm** (No libraries, no regex):

1. **Initialize**: `last_t_index = -1`
2. **Scan forward**: Loop through entire string
   - Each time 'T' is found, update `last_t_index = i`
   - After loop completes, `last_t_index` holds position of last T
3. **Check**: If `last_t_index == -1`, no T exists → return unchanged
4. **Reconstruct**: `dna[:last_t_index] + 'A' + dna[last_t_index + 1:]`
:::

## Key Difference from TM

- Single forward pass vs. TM's two-phase scan (right then left)
- Direct string indexing vs. tape head movements
- Both achieve O(n) time complexity

## LastTtoA Turing Machine

![State Diagram](lastTtoA.png)

## LasttoA Turing Machine Implementation

## Complete Computation of the LastTtoA Machine

![Complete Computation](lastTtoA_2.png){height=50%}

## Hemani's Code Examples

## LastTtoA using Regex

```{pyodide}
#| autorun: true
#| max-lines: 15
"""Implementing LastTtoA function using regex."""
import re

def main(input_str: str):
    input = input_str.lower()
    last_t_position = -1
    search_for_t = r"t"
    found_t = re.finditer(search_for_t, input)
    last_match = None

    for find_t in found_t:
        last_match = find_t

    if last_match is not None:
        last_t_position = last_match.start()
        output = input[:last_t_position] + 'a' + input[last_t_position+1:]
    else:
        output = input

    print(output)


if __name__ == "__main__":
    main("ATCGT")
    main("TTTT")
    main("ACGAA")
    main("T")
```

## Comprehensive Test Suite

::: {.fragment}
**Professional Testing Approach**: Created unified test suite validating all implementations
:::

```python
def test_all_implementations():
    """Test all LastTtoA implementations with identical test cases."""
    test_cases = [
        ("ATCGT", "ATCGA"),      # Basic case
        ("TTTT", "TTTA"),        # Multiple T's
        ("ACGAA", "ACGAA"),      # No T's
        ("T", "A"),              # Single T
        ("", ""),                # Empty string
        ("ACGTACGT", "ACGTACGA") # Complex case
    ]
    
    implementations = [
        ("Turing Machine", turing_lastTtoA),
        ("Pure Python", lastTtoA_plain),
        ("Regex Python", lastTtoA_regex)
    ]
    
    for name, func in implementations:
        print(f"\nTesting {name}:")
        for input_str, expected in test_cases:
            result = func(input_str)
            status = "✓" if result == expected else "✗"
            print(f"  {status} '{input_str}' → '{result}' (expected: '{expected}')")
```

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}
**Verification**: All implementations produce identical results across comprehensive test cases
:::

## Test Results and Validation

::: {.fragment}
**Testing Methodology**:
- **Unit Testing**: Individual function validation
- **Integration Testing**: Cross-implementation consistency
- **Performance Testing**: Execution time comparison
- **Edge Case Testing**: Boundary condition validation
:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}
**Key Finding**: All four implementations (TM, Pure Python, Regex, C++) produce identical outputs for identical inputs
:::

## Conclusion

::: {.fragment}
**Deterministic Turing Machine**: Formal 3-state machine with transition function (q0 → q1 → qhalt, tape operations)

- Example: `ATCGT⊔` → scan right → scan left → replace T → `ATCGA`

**Pure Python**: We used Loop-based scanning with string slicing reconstruction

- Example:
```py
for i in range(len(dna)):
  if dna[i] == 'T':
    last_t_index = i
```

**Python with Regex**: Implemented pattern matching to locate and process the last 'T' and transformation to 'A'

**Non-Python Implementation**:

**Result**: All implementations produce `"ATCGT"` → `"ATCGA"` 

**Comprehensive Testing**: All implementations validated with identical test suites

**Theoretical Analysis**: LastTtoA is **computable** and **tractable** (O(n))
:::

## Key Insights

::: {.fragment}
- **Universality**: Same problem solvable across different computational models
- **Efficiency**: All approaches achieve optimal O(n) time complexity
- **Correctness**: Formal verification through comprehensive testing
:::
