---
title: "Polynomial-time Mapping Reductions"
description: "Prove that X is as easy as Y"
date: "2025-12-01"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof
techniques to correctly distinguish between problems that are tractable,
intractable, and uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine
(TM) abstraction to both describe and analyze the solution to a
computational problem.
- **CS-204-3**: Correctly use one or more variants of the finite state
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a
problem according to whether or not it is in the P, NP, NP-Hard, and/or
NP-Complete complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the
limits of either program feasibility or complexity to the implementation
of both correct and efficient real-world Python programs.

:::

## Review of key concepts

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid circle-check >}} **Poly**: Problems solvable in
polynomial time $O(n^k)$
- {{< iconify fa6-solid circle-check >}} **PolyCheck/NPoly**: Problems
with polytime verification
- {{< iconify fa6-solid circle-check >}} **Equivalence**: PolyCheck =
NPoly (proven!)
- {{< iconify fa6-solid question >}} **Open question**: Is Poly $\subset$
PolyCheck/NPoly?
- {{< iconify fa6-solid link >}} **Need tools**: How do we compare
problem difficulty?

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions provide comparison tools**: we need formal techniques to
prove that one problem is "as hard as" another. This chapter introduces
**polynomial-time mapping reductions** that let proofgrammers establish
relationships between computational problems! **Let's dive in**!

:::

# Polyreductions prove X is as easy as Y! Helpful!

::: {.fragment .boxed-content style="font-size: 0.875em;"}

{{< iconify fa6-solid link >}} **Polynomial-time mapping reductions** help
with learning objectives **CS-204-1** and **CS-204-4**. We will define a
powerful technique for **comparing problem difficulty**. This technique lets
us prove that if we can solve problem $Y$ efficiently, then we can also solve
problem $X$ efficiently. **As proofgrammers, let's explore how to establish
formal relationships between computational problems**!

:::

## Focus on decision problems

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid circle-info >}} **Focus shift**: Rest of course uses
decision problems
- {{< iconify fa6-solid rocket >}} **Previous definitions**: PACKING, PARTITION
were nondecision problems
- {{< iconify fa6-solid circle-check >}} **Now converted**: All problems become
decision problems, which can be done in a mechanical fashion, no generality
loss from proof perspective
- {{< iconify fa6-solid lightbulb >}} **Why?**: Building to NP-completeness,
only defined for decision problems
- {{< iconify fa6-solid arrow-right >}} **Example**: PARTITION returns `yes` or
`no`, not the computed partition

:::

::: {.fragment .fade .boxed-content style="font-size: 0.75em;"}

**Decision problems simplify theoretical analysis**: by focusing on yes/no
questions, we can more elegantly state and prove hardness results. This is a
standard in complexity theory! The fundamental ideas remain the same!

:::

# Two reduction methods

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid shuffle >}} **Two reduction types**: Turing 
versus polynomial-time mapping reductions
- {{< iconify fa6-solid stopwatch >}} **Key difference**: Time constraints
and number of oracle calls
- {{< iconify fa6-solid microscope >}} **Turing reductions**: Prove
computability relationships, unlimited time
- {{< iconify fa6-solid rocket >}} **Polyreductions**: Prove efficiency
relationships, polynomial time
- {{< iconify fa6-solid balance-scale >}} **Why compare?**: Understanding
restrictions helps choose right tool

:::

::: {.fragment .boxed-content .fade style="margin-top: -0.25em; font-size: 0.7em;"}

{{< iconify fa6-solid gears >}} **Polyreductions are more restrictive but more
powerful for complexity**: by requiring polynomial-time transformations, they
preserve efficiency relationships. This makes them perfect for comparing problem
difficulty in complexity theory!

:::

## Recall: Turing reductions

![](13-polyreductions_0.png)

::: {.fragment style="font-size: 0.85em;"}

- **Turing reduction**: Solve problem $X$ by calling $Y$ as a subroutine
- **No time limit**: Can use $Y$ multiple times, any running time
- **Used for**: Proving compujability relationships

:::

::: {.fragment .boxed-content .fade style="margin-top: -0.25em; font-size: 0.8em;"}

{{< iconify fa6-solid gears >}} Turing reductions played a central role in
creating the tree of uncomputable problems through a proof-by-contradiction
technique. Now, we define a new reduction to help with complexity!

:::

## Polynomial-time mapping reductions

![](13-polyreductions_1.png)

::: {.fragment style="font-size: 0.85em;"}

- **Polyreduction**: Transform $X$ instance to $Y$ instance in polytime
- **Call once**: Only one call to $Y$, then transform result back
- **Strict constraint**: Transformation must run in polynomial time
- **Used for**: Proving efficiency relationships between problems

:::

## Key differences between reduction types

::: {.incremental style="margin-top: -0.25em; font-size: 0.8em;"}

- {{< iconify fa6-solid stopwatch >}} **Time constraint**: Polyreductions
require polynomial-time transformation
- {{< iconify fa6-solid phone >}} **Number of calls**: Turing reductions
can call $Y$ multiple times
- {{< iconify fa6-solid map >}} **Mapping**: Polyreductions map instances
directly, preserving structure
- {{< iconify fa6-solid rocket >}} **Efficiency**: Polyreductions preserve
polynomial-time solvability
- {{< iconify fa6-solid microscope >}} **Purpose**: Polyreductions compare
complexity, not just computability

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions are more restrictive but more powerful**: the polynomial-time
constraint means that polyreductions reveal efficiency relationships, not just
computability relationships! This makes them perfect for complexity theory!

:::

# Formal definition of polyreduction

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid book >}} **Formal notation**: $X \leq_P Y$ means "X
polyreduces to Y"
- {{< iconify fa6-solid list-check >}} **Three conditions**: Must verify all
three for valid reduction
- {{< iconify fa6-solid map >}} **Transformation function**: Convert X
instances to Y instances
- {{< iconify fa6-solid arrow-right >}} **Interpretation**: If Y is easy, then
X is easy
- {{< iconify fa6-solid graduation-cap >}} **Proof structure**: Always verify
pos→pos, neg→neg, polytime

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **The three conditions work together**: they
ensure that solving Y efficiently lets us solve X efficiently. Proofgrammers
must verify all three conditions in every polyreduction proof!

:::

## Polyreduction definition

![](13-polyreductions_2.png)

::: {.fragment style="font-size: 0.85em;"}

- **Notation**: $X \leq_P Y$ means "$X$ polyreduces to $Y$"
- **Three conditions**: pos→pos, neg→neg, and polytime transformation
- **Transformation**: Function $R$ converts $X$ instances to $Y$ instances
- **Interpretation**: If we can solve $Y$, we can solve $X$ efficiently

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

{{< iconify fa6-solid gears >}} Can you see why all three conditions are
necessary? What happens if the transformation doesn't preserve positive
instances? Or if it runs in exponential time?

:::

## Polyreduce PARTITION to PACKING

![](13-polyreductions_3.png)

::: {.fragment style="font-size: 0.85em;"}

- **Transform**: Convert PARTITION instance to PACKING instance
- **Preserve structure**: Positive instances map to positive instances
- **Key insight**: Both problems involve subset selection with constraints
- **Verify**: Check pos→pos, neg→neg, and polynomial time

:::

# Compare Turing and poly reductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid code-branch >}} **Turing reductions**: Multiple calls,
adaptive, no time bound
- {{< iconify fa6-solid map-marked >}} **Polyreductions**: Single
transformation, fixed, polynomial time
- {{< iconify fa6-solid lightbulb >}} **Trade-off**: Flexibility vs stronger
guarantees
- {{< iconify fa6-solid trophy >}} **Power comparison**: Polyreductions reveal
efficiency relationships
- {{< iconify fa6-solid forward >}} **Complexity theory**: Polyreductions are
the right tool

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Restrictions create power**: by limiting to
polynomial time and single transformations, polyreductions give us exactly what
we need for NP-completeness theory!

:::

## Turing reduction flexibility

![](13-polyreductions_4.png)

::: {.fragment style="font-size: 0.85em;"}

- **Multiple calls**: Can invoke subroutine many times
- **Adaptive**: Can make decisions based on previous calls
- **No time bound**: Calls can take arbitrary time
- **Weaker result**: Only proves computability relationship

:::

## Polyreduction constraints

![](13-polyreductions_5.png)

::: {.fragment style="font-size: 0.85em;"}

- **Single transformation**: Map once from $X$ to $Y$
- **Fixed mapping**: Cannot adapt based on $Y$'s answer
- **Time bounded**: Transformation must be polynomial
- **Stronger result**: Proves efficiency relationship

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions are stricter but reveal more**: the constraints mean that
$X \leq_P Y$ tells us that $X$ is "no harder" than $Y$ in terms of
computational complexity! This is exactly what we need for NP-completeness!

:::

# Proof technique for polyreductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid clipboard-list >}} **Standard template**: Same proof
structure for all polyreductions
- {{< iconify fa6-solid check-double >}} **Condition 1**: Positive instances
map to positive instances
- {{< iconify fa6-solid times-circle >}} **Condition 2**: Negative instances
map to negative instances
- {{< iconify fa6-solid clock >}} **Condition 3**: Transformation runs in
polynomial time
- {{< iconify fa6-solid pencil >}} **Proof strategy**: Describe
transformation, verify all three

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Follow this template every time**: systematic
verification of all three conditions ensures correctness. Proofgrammers should
make this second nature!

:::

## Three conditions to verify

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid arrow-right >}} **Condition 1 (pos→pos)**: Every
positive instance of $X$ maps to a positive instance of $Y$
- {{< iconify fa6-solid arrow-left >}} **Condition 2 (neg→neg)**: Every
negative instance of $X$ maps to a negative instance of $Y$
- {{< iconify fa6-solid stopwatch >}} **Condition 3 (polytime)**: The
transformation $R$ runs in polynomial time
- {{< iconify fa6-solid lightbulb >}} **Key insight**: Conditions 1 and 2
together ensure correctness
- {{< iconify fa6-solid rocket >}} **Why polytime?**: Ensures efficiency
is preserved

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Follow this template for every polyreduction proof**: (1) describe the
transformation, (2) prove pos→pos, (3) prove neg→neg, (4) analyze running time.
This systematic approach works for all polyreduction proofs!

:::

# Graph polyreductions with Hamilton cycles

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid project-diagram >}} **Hamilton cycles**: Visit every
vertex exactly once, return to start
- {{< iconify fa6-solid arrows-alt >}} **Two variants**: Undirected (UHC) and
directed (DHC) graphs
- {{< iconify fa6-solid question >}} **Relationship**: Are they equally hard?
- {{< iconify fa6-solid exchange-alt >}} **Goal**: Show UHC $\equiv_P$ DHC via
bidirectional reductions
- {{< iconify fa6-solid tools >}} **Technique**: Graph transformation gadgets

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Hamilton cycle problems are NP-complete**:
understanding these reductions helps us see why seemingly different problems
have the same computational difficulty!

:::

## Two important graph problems

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid project-diagram >}} **UHC (Undirected Hamilton
Cycle)**: Does an undirected graph have a Hamilton cycle?
- {{< iconify fa6-solid arrow-right >}} **DHC (Directed Hamilton Cycle)**:
Does a directed graph have a Hamilton cycle?
- {{< iconify fa6-solid question >}} **Relationship**: How do these
problems compare?
- {{< iconify fa6-solid link >}} **Goal**: Prove polyreduction
relationships between them
- {{< iconify fa6-solid lightbulb >}} **Key trick**: Convert graph
representations

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Hamilton cycles are fundamental**: many NP-complete problems involve finding
paths or cycles that visit all vertices. Understanding these problems is crucial
for complexity theory!

:::

## Polyreduce UHC to DHC

![](13-polyreductions_6.png)

::: {.fragment style="font-size: 0.85em;"}

- **Key trick**: Convert each undirected edge into two directed edges
- **Exercise**: Prove pos→pos, neg→neg, and polytime conditions
- **Intuition**: Undirected edge allows travel both ways

:::

## Polyreduce DHC to UHC

![](13-polyreductions_7.png)

::: {.fragment style="font-size: 0.85em;"}

- **Key trick**: Convert each node into connected "triplets"
- **Exercise**: Prove pos→pos, neg→neg, and polytime conditions
- **Intuition**: Triplets enforce directional constraints

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Bidirectional polyreductions**: Since UHC $\leq_P$ DHC and DHC $\leq_P$ UHC,
these problems are equally hard! This is called polyequivalence and we'll
formalize it later!

:::

# Satisfiability problems are fundamental

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid microchip >}} **Boolean satisfiability**: Can we make
a formula or circuit output True?
- {{< iconify fa6-solid layer-group >}} **Three variants**: CircuitSAT, SAT,
and 3-SAT
- {{< iconify fa6-solid link >}} **All polyequivalent**: CircuitSAT $\equiv_P$
SAT $\equiv_P$ 3-SAT
- {{< iconify fa6-solid trophy >}} **Central importance**: Foundation for
NP-completeness theory
- {{< iconify fa6-solid tools >}} **Real applications**: Circuit design,
verification, planning

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **SAT problems are everywhere**: from
verifying computer chips to scheduling problems. Understanding their equivalence
helps us see the deep connections in computational complexity!

:::

## CircuitSAT: Can a circuit output 1?

![](13-polyreductions_8.png)

::: {.fragment style="font-size: 0.85em;"}

- **Input**: Boolean circuit with variables
- **Question**: Exists assignment making output = 1?
- **Example**: Circuit with AND, OR, NOT gates
- **Applications**: Circuit verification and design

:::

## SAT: Can a formula be satisfied?

![](13-polyreductions_10.png)

::: {.fragment style="font-size: 0.85em;"}

- **Input**: Boolean formula in CNF (AND of ORs)
- **Question**: Exists assignment making formula True?
- **CNF example**: $(x_1 \vee \neg x_2) \wedge (x_2 \vee x_3)$
- **Restriction**: CircuitSAT limited to formula structure

:::

## 3-SAT: At most 3 literals per clause

![](13-polyreductions_11.png)

::: {.fragment style="font-size: 0.85em;"}

- **Input**: CNF formula with $\leq$ 3 literals per clause
- **Question**: Same as SAT, stricter format
- **Example**: $(x \vee y \vee z) \wedge (\neg x \vee y)$
- **Surprising**: No easier than general SAT!

:::

# Polyreductions between SAT variants

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid arrow-right >}} **Reduction chain**: CircuitSAT
$\leq_P$ SAT $\leq_P$ 3-SAT
- {{< iconify fa6-solid equals >}} **Polyequivalence**: All three equally hard
- {{< iconify fa6-solid magic >}} **Key technique**: Transform structure while
preserving satisfiability
- {{< iconify fa6-solid puzzle-piece >}} **CircuitSAT to SAT**: Convert gates
to clauses
- {{< iconify fa6-solid scissors >}} **SAT to 3-SAT**: Split long clauses
using dummy variables

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **The reduction chain proves equivalence**:
each transformation preserves satisfiability in polynomial time, showing all
three problems have the same fundamental difficulty!

:::

## CircuitSAT to SAT: Main idea

![](13-polyreductions_14.png)

::: {.fragment style="font-size: 0.85em;"}

- **Transform**: Each gate becomes clauses enforcing its logic
- **AND gate**: $z = x \wedge y$ becomes clauses about $x, y, z$
- **OR gate**: $z = x \vee y$ becomes different clauses
- **Result**: Formula satisfiable iff circuit satisfiable

:::

## SAT to 3-SAT: Clause splitting

![](13-polyreductions_15.png)

::: {.fragment style="font-size: 0.85em;"}

- **Problem**: Clause $(x_1 \vee x_2 \vee x_3 \vee x_4)$ too long
- **Solution**: Split using dummy variable $z$
- **Result**: $(x_1 \vee x_2 \vee z) \wedge (\neg z \vee x_3 \vee x_4)$
- **Preserves**: Original satisfiable iff split version satisfiable

:::

# Polyequivalence captures equal difficulty

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid equals >}} **Polyequivalence**: When problems $X$ and
$Y$ reduce to each other
- {{< iconify fa6-solid scale-balanced >}} **Equal difficulty**: $X \equiv_P
Y$ means same computational hardness
- {{< iconify fa6-solid link >}} **Transitivity**: Polyreductions compose to
create equivalence classes
- {{< iconify fa6-solid layer-group >}} **Complexity classes**: Groups of
equally hard problems
- {{< iconify fa6-solid forward >}} **NP-completeness preview**: Foundation
for next chapter's theory

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Polyequivalence partitions problems into
difficulty classes**: if solving one problem in the class efficiently solves
all problems in that class, then they form a natural unit of study. This
creates the mathematical structure underlying NP-completeness!

:::

## Definition of polyequivalence

![](13-polyreductions_19.png)

::: {.fragment style="font-size: 0.85em;"}

- **Definition**: $X \equiv_P Y$ if $X \leq_P Y$ and $Y \leq_P X$
- **Meaning**: Problems are equally hard
- **Examples**: UHC $\equiv_P$ DHC, CircuitSAT $\equiv_P$ SAT $\equiv_P$
3-SAT
- **Transitivity**: If $X \equiv_P Y$ and $Y \equiv_P Z$, then $X \equiv_P
Z$

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyequivalence creates complexity classes**: problems that are
polyequivalent have the same fundamental difficulty. This is the foundation for
NP-completeness theory in the next chapter!

:::

## Key insights for proofgrammers

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid check-circle >}} **Polyreductions**: Compare
problem difficulty via transformations
- {{< iconify fa6-solid check-circle >}} **Three conditions**: pos→pos,
neg→neg, and polytime
- {{< iconify fa6-solid check-circle >}} **SAT problems**: CircuitSAT,
SAT, and 3-SAT are fundamental
- {{< iconify fa6-solid check-circle >}} **Polyequivalence**: $X \equiv_P
Y$ means equal difficulty
- {{< iconify fa6-solid check-circle >}} **Proof technique**: Describe
transformation, verify conditions
- {{< iconify fa6-solid check-circle >}} **Next chapter**: NP-completeness
builds on these ideas!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions are the foundation of complexity theory**: they let us prove
that problems are equally hard and establish a hierarchy of difficulty. Next,
we'll use these tools to identify the "hardest" problems in NP!

:::
