---
title: "Polynomial-time Mapping Reductions"
description: "Prove that X is as easy as Y"
date: "2025-12-01"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof
techniques to correctly distinguish between problems that are tractable,
intractable, and uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine
(TM) abstraction to both describe and analyze the solution to a
computational problem.
- **CS-204-3**: Correctly use one or more variants of the finite state
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a
problem according to whether or not it is in the P, NP, NP-Hard, and/or
NP-Complete complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the
limits of either program feasibility or complexity to the implementation
of both correct and efficient real-world Python programs.

:::

## Review of key concepts

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid circle-check >}} **Poly**: Problems solvable in
polynomial time $O(n^k)$
- {{< iconify fa6-solid circle-check >}} **PolyCheck/NPoly**: Problems
with polytime verification
- {{< iconify fa6-solid circle-check >}} **Equivalence**: PolyCheck =
NPoly (proven!)
- {{< iconify fa6-solid question >}} **Open question**: Is Poly $\subset$
PolyCheck/NPoly?
- {{< iconify fa6-solid link >}} **Need tools**: How do we compare
problem difficulty?

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions provide comparison tools**: we need formal techniques to
prove that one problem is "as hard as" another. This chapter introduces
**polynomial-time mapping reductions** that let proofgrammers establish
relationships between computational problems! **Let's dive in**!

:::

# Polyreductions prove X is as easy as Y! Helpful!

::: {.fragment .boxed-content style="font-size: 0.875em;"}

{{< iconify fa6-solid link >}} **Polynomial-time mapping reductions** help
with learning objectives **CS-204-1** and **CS-204-4**. We will define a
powerful technique for **comparing problem difficulty**. This technique lets
us prove that if we can solve problem $G$ efficiently, then we can also solve
problem $F$ efficiently. **As proofgrammers, let's explore how to establish
formal relationships between computational problems**!

:::

## Focus on decision problems

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid circle-info >}} **Focus shift**: Rest of course uses
decision problems
- {{< iconify fa6-solid rocket >}} **Previous definitions**: PACKING, PARTITION
were nondecision problems
- {{< iconify fa6-solid circle-check >}} **Now converted**: All problems become
decision problems, which can be done in a mechanical fashion, no generality
loss from proof perspective
- {{< iconify fa6-solid lightbulb >}} **Why?**: Building to NP-completeness,
only defined for decision problems
- {{< iconify fa6-solid arrow-right >}} **Example**: PARTITION returns `yes` or
`no`, not the computed partition

:::

::: {.fragment .fade .boxed-content style="font-size: 0.75em;"}

**Decision problems simplify theoretical analysis**: by focusing on yes/no
questions, we can more elegantly state and prove hardness results. This is a
standard in complexity theory! The fundamental ideas remain the same!

:::

# Two reduction methods

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid shuffle >}} **Two reduction types**: Turing 
versus polynomial-time mapping reductions
- {{< iconify fa6-solid stopwatch >}} **Key difference**: Time constraints
and number of oracle calls
- {{< iconify fa6-solid microscope >}} **Turing reductions**: Prove
computability relationships, unlimited time
- {{< iconify fa6-solid rocket >}} **Polyreductions**: Prove efficiency
relationships, polynomial time
- {{< iconify fa6-solid scale-balanced >}} **Why compare?**: Understanding
restrictions helps choose right tool

:::

::: {.fragment .boxed-content .fade style="margin-top: -0.25em; font-size: 0.7em;"}

{{< iconify fa6-solid gears >}} **Polyreductions are more restrictive but more
powerful for complexity**: by requiring polynomial-time transformations, they
preserve efficiency relationships. This makes them perfect for comparing problem
difficulty in complexity theory!

:::

## Recall: Turing reductions

![](13-polyreductions_0.png)

::: {.fragment style="font-size: 0.85em;"}

- **Turing reduction**: Solve problem $F$ by calling $G$ as a subroutine
- **No time limit**: Focus is not on transformation's efficiency
- **Used for**: Proving computability relationships among problems

:::

::: {.fragment .boxed-content .fade style="margin-top: -0.25em; font-size: 0.8em;"}

{{< iconify fa6-solid gears >}} Turing reductions played a central role in
creating the tree of uncomputable problems through a proof-by-contradiction
technique. **Now, we define a new reduction to help with computational
complexity**!

:::

## Polynomial-time mapping reductions

![](13-polyreductions_1.png)

::: {.fragment style="font-size: 0.85em;"}

- **Polyreduction**: Transform $F$ instance to $G$ instance in polytime
- **Call once**: Only one call to $G$, then transform result back
- **Strict constraint**: Transformation must run in polynomial time
- **Purpose**: Proving efficiency relationships between problems
- **Reminder**: We will often use the shortcut phrase "polyreduces" for the
longer phrase "polynomial-time mapping reduces"

:::

## Differences between reduction types

::: {.incremental style="margin-top: -0.25em; font-size: 0.8em;"}

- {{< iconify fa6-solid stopwatch >}} **Time constraint**: Polyreductions
require polynomial-time transformation
- {{< iconify fa6-solid map >}} **Mapping**: Polyreductions map instances
directly, preserving structure
- {{< iconify fa6-solid rocket >}} **Efficiency**: Polyreductions preserve
polynomial-time solvability
- {{< iconify fa6-solid microscope >}} **Purpose**: Polyreductions compare
complexity, not just computability

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions are more restrictive but more powerful**: the polynomial-time
constraint means that polyreductions reveal efficiency relationships, not just
computability relationships! This makes them perfect for complexity theory! Can
you see how this builds on the "reduction concept" and then extends it? *Okay,
let's formally defintine polyreductions!*

:::

# Formal definition of polyreduction

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid book >}} **Formal notation**: $F \leq_P G$ means
"F polyreduces to G"
- {{< iconify fa6-solid list-check >}} **Three conditions**: Must verify all
three for valid reduction
- {{< iconify fa6-solid map >}} **Transformation function**: Convert $F$
instances to $G$ instances
- {{< iconify fa6-solid arrow-right >}} **Interpretation**: If $G$ is
efficiently solvable, then $F$ is also!
- {{< iconify fa6-solid graduation-cap >}} **Proof structure**: Always verify
pos→pos, neg→neg, polytime

:::

::: {.fragment .boxed-content .fade style="margin-top: -0.25em; font-size: 0.7em;"}

{{< iconify fa6-solid gears >}} **Three conditions work together**: they ensure
that solving $G$ efficiently lets us solve $F$ efficiently. Proofgrammers must
verify all three conditions in every proof!

:::

## Polyreduction definition

![](13-polyreductions_2.png)

::: {.fragment style="font-size: 0.85em;"}

- **Notation**: $F \leq_P G$ means "$F$ polyreduces to $G$"
- **Three conditions**: pos→pos, neg→neg, and polytime transformation
- **Transformation**: Function $C$ converts $F$ instances to $G$ instances
- **Interpretation**: If we can solve $G$, we can solve $F$ efficiently

:::

## Recall: PACKING problem

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid box >}} **Input**: Weights $w_1, w_2,
\ldots, w_m$ and thresholds $L$ and $H$
- {{< iconify fa6-solid truck >}} **Metaphor**: Load packages into delivery
truck with weight limits
- {{< iconify fa6-solid question >}} **Question**: Can we select subset with
total weight between $L$ and $H$?
- {{< iconify fa6-solid check >}} **Example**: Weights "12 4 6 24 4 16; 20; 27"
→ solution "4 6 16" (total = 26)
- {{< iconify fa6-solid star >}} **In PolyCheck**: Easy to verify a proposed
packing, hard to find one

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

{{< iconify fa6-solid rocket >}} **Quick PolyCheck reminder**: A problem is in
PolyCheck if we can verify a proposed solution in polynomial time, even if
finding that solution might be hard. PACKING fits perfectly: given a subset, we
just sum the weights and check if $L \leq \text{sum} \leq H$ in $O(n)$
time! **How connects to PARTITION**?

:::

## Recall: PARTITION problem

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid box >}} **Input**: Just weights $w_1, w_2, \ldots,
w_m$ (no thresholds!)
- {{< iconify fa6-solid rocket >}} **Goal**: Split into two equal-weight
subsets
- {{< iconify fa6-solid question >}} **Question**: Can we partition weights so
each half has same total?
- {{< iconify fa6-solid check >}} **Example**: Weights "12 4 6 14 4 16" →
solution "12 16" (total = 28) vs "4 6 14 4" (total = 28). Can you explain this
example in detail?
- {{< iconify fa6-solid link >}} **Relationship**: PARTITION is PACKING where
$L = H = \frac{\text{total weight}}{2}$

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Both problems are in PolyCheck**: checking a proposed solution is easy (just
sum the weights), but finding a solution seems hard. This makes them perfect
examples for polyreductions! Let's polyreduce PARTITION to PACKING. **Make sure
to confirm the three key conditions as we go**!

:::

## Polyreduce PARTITION to PACKING

![](13-polyreductions_3.png)

::: {.fragment style="font-size: 0.85em;"}

- **Transform**: Convert PARTITION instance to PACKING instance
- **Preserve structure**: Positive instances map to positive instances
- **Key insight**: Both problems involve subset selection with constraints
- **Verify**: Check pos→pos, neg→neg, and polynomial time

:::

# Compare Turing and polyreductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid code-branch >}} **Turing reductions**: Multiple calls
to $G$, adaptive, no time bound
- {{< iconify fa6-solid map-location-dot >}} **Polyreductions**: 
Transformation from $F$ to $G$, polynomial time
- {{< iconify fa6-solid lightbulb >}} **Trade-off**: Flexibility vs stronger
guarantees
- {{< iconify fa6-solid trophy >}} **Power comparison**: Polyreductions reveal
efficiency relationships
- {{< iconify fa6-solid forward >}} **Complexity theory**: Polyreductions are
the right tool

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Restrictions create power**: by limiting to
polynomial time and single transformations, polyreductions give us exactly what
we need for NP-completeness theory! We will soon explore the definition of
NP-completeness using these tools!

:::

## Turing reduction flexibility

![](13-polyreductions_4.png)

::: {.fragment style="font-size: 0.85em;"}

- **No time bound**: Calls can take arbitrary time
- **Weaker result**: Only proves computability relationship

:::

## Polyreduction constraints

![](13-polyreductions_5.png)

::: {.fragment style="font-size: 0.85em;"}

- **Time bounded**: Transformation must be polynomial
- **Stronger result**: Proves efficiency relationship

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions are stricter but reveal more**: the constraints mean that
$F \leq_P G$ tells us that $F$ is "no harder" than $G$ in terms of
computational complexity! Hooray, this is exactly what we need for NP-completeness!

:::

# Proof technique for polyreductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid clipboard-list >}} **Standard template**: Same proof
structure for all polyreductions
- {{< iconify fa6-solid check-double >}} **Condition 1**: Positive instances
map to positive instances
- {{< iconify fa6-solid circle-check >}} **Condition 2**: Negative instances
map to negative instances
- {{< iconify fa6-solid clock >}} **Condition 3**: Transformation runs in
polynomial time
- {{< iconify fa6-solid pencil >}} **Proof strategy**: Describe
transformation, verify all three

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Follow this template every time**: systematic
verification of all three conditions ensures correctness. Proofgrammers should
make this second nature!

:::

## Three conditions to verify

::: {.incremental style="margin-top: -0.5em; font-size: 0.68em;"}

- {{< iconify fa6-solid arrow-right >}} **Condition 1 (pos→pos)**: Every
positive instance of $F$ maps to a positive instance of $G$
- {{< iconify fa6-solid arrow-left >}} **Condition 2 (neg→neg)**: Every
negative instance of $F$ maps to negative instance of $G$
- {{< iconify fa6-solid stopwatch >}} **Condition 3 (polytime)**: The
transformation $C$ runs in polynomial time
- {{< iconify fa6-solid lightbulb >}} **Key insight**: Conditions 1 and 2
together ensure correctness
- {{< iconify fa6-solid rocket >}} **Why polytime?**: Ensures efficiency
is preserved, which is critical for complexity

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Follow this template for every polyreduction proof**: (1) describe the
transformation, (2) prove pos→pos, (3) prove neg→neg, (4) analyze running time.
This systematic approach works for all polyreduction proofs!

:::

::: fragment

- **Next**: Investigate graph problems with Hamilton cycles
- **Then**: Explore satisfiability problems: CircuitSAT, SAT, 3-SAT

:::

# Graph polyreductions with Hamilton cycles

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- **Hamilton cycles**: Visit every vertex exactly once, return to start
-  **Two variants**: Undirected (UHC) and directed (DHC) graphs
- **Relationship**: Are they equally hard?
- **Goal**: Show UHC $\equiv_P$ DHC via bidirectional reductions
- **Technique**: Graph transformation gadgets

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Hamilton cycle problems are NP-complete**:
understanding these reductions helps us see why seemingly different problems
have the same computational difficulty! It turns out that UHC and DHC are
equally hard! But, can we prove it?

:::

## Two important graph problems

::: {.incremental style="margin-top: -0.25em; font-size: 0.825em;"}

- {{< iconify fa6-solid diagram-project >}} **UHC**: Does an undirected graph
have a Hamilton cycle?
- {{< iconify fa6-solid arrow-right >}} **DHC**: Does a directed graph have a
Hamilton cycle?
- {{< iconify fa6-solid question >}} **Relationship**: How do these problems
compare?
  - Is it harder to solve the problem with directed or undirected edges?
  - Or, are directed and undirected edges equally hard to handle?
- {{< iconify fa6-solid link >}} **Goal**: Prove polyreduction relationships
between them
- {{< iconify fa6-solid lightbulb >}} **Key trick**: Convert graph
representations efficiently

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Hamilton cycles are fundamental**: many NP-complete problems involve finding
paths or cycles that visit all vertices. Understanding these problems is crucial
for complexity theory! This also influences practical methods!

:::

## Polyreduce UHC to DHC

![](13-polyreductions_6.png)

::: {.fragment style="font-size: 0.85em;"}

- **Key trick**: Convert each undirected edge into two directed edges
- **Exercise**: Prove pos→pos, neg→neg, and polytime conditions
- **Intuition**: Undirected edge allows travel both ways

:::

## Polyreduce DHC to UHC

![](13-polyreductions_7.png)

::: {.fragment style="font-size: 0.85em;"}

- **Key trick**: Convert each node into connected "triplets"
- **Exercise**: Prove pos→pos, neg→neg, and polytime conditions
- **Intuition**: Triplets enforce directional constraints

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Bidirectional polyreductions**: Since UHC $\leq_P$ DHC and DHC $\leq_P$ UHC,
these problems are equally hard! This is called polyequivalence!

:::

# Satisfiability problems are fundamental

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid microchip >}} **Boolean satisfiability**: Can we make
a formula or circuit output True?
- {{< iconify fa6-solid layer-group >}} **Three variants**: CircuitSAT, SAT,
and 3-SAT
- {{< iconify fa6-solid link >}} **All polyequivalent**: CircuitSAT $\equiv_P$
SAT $\equiv_P$ 3-SAT
- {{< iconify fa6-solid trophy >}} **Central importance**: Foundation for
NP-completeness theory
- {{< iconify fa6-solid gears >}} **Real applications**: Circuit design,
verification, planning

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **SAT problems are everywhere**: from verifying
computer chips to scheduling problems to software testing. Understanding their
equivalence helps us see the deep connections in computational complexity! Let's 
start with some circuits!

:::

## CircuitSAT: Can a circuit output 1?

![](13-polyreductions_8.png)

::: {.fragment style="font-size: 0.85em;"}

- **Input**: Boolean circuit with variables
- **Question**: Exists assignment making output = 1?
- **Example**: Circuit with AND, OR, NOT gates
- **Applications**: Circuit verification and design

:::

## SAT: Can a formula be satisfied?

![](13-polyreductions_10.png)

::: {.fragment style="font-size: 0.85em;"}

- **Input**: Boolean formula in CNF (AND of ORs)
  - $x_1$ through $x_5$ are boolean variables
  - $\neg x_2$ is the logical negation of $x_2$
  - $(x_1 \vee \neg x_2)$ is a logical OR clause
  - $x_1 \wedge x_2$ combines clauses with logical AND
- **Question**: Exists assignment making formula True?
- **CNF example**: $(x_1 \vee \neg x_2) \wedge (x_2 \vee x_3)$
- **Restriction**: CircuitSAT limited to formula structure

:::

## 3-SAT: At most 3 literals per clause

![](13-polyreductions_11.png)

::: {.fragment style="font-size: 0.85em;"}

- **Input**: CNF formula with $\leq$ 3 literals per clause
- **Question**: Same as SAT, stricter format, are their differences?
- **Surprising**: No easier than general SAT!

:::

# Polyreductions for SATs

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid arrow-right >}} **Reduction claims**:
  - CircuitSAT $\leq_P$ SAT
  - SAT $\leq_P$ CircuitSAT
  - 3-SAT $\leq_P$ SAT
  - SAT $\leq_P$ 3-SAT
- {{< iconify fa6-solid equals >}} **Polyequivalence**: All three equally hard
- {{< iconify fa6-solid star >}} **Key technique**: Transform structure while
preserving satisfiability

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **The reduction chain proves equivalence**: each
transformation preserves satisfiability in polynomial time, showing all three
problems have the same fundamental difficulty! Wow, this is an impressive
result!

:::

## CircuitSAT to SAT: Main idea

![](13-polyreductions_14.png)

::: {.fragment style="font-size: 0.85em;"}

- **Transform**: Each gate becomes clauses enforcing its logic
- **AND gate**: $z = x \wedge y$ becomes clauses about $x, y, z$
- **OR gate**: $z = x \vee y$ becomes different clauses
- **Result**: Formula satisfiable *iff* circuit satisfiable

:::

## SAT to 3-SAT: Clause splitting

![](13-polyreductions_15.png)

::: {.fragment style="font-size: 0.85em;"}

- **Problem**: Clause $(x_1 \vee x_2 \vee x_3 \vee x_4)$ too long
- **Solution**: Split using dummy variable $z$
- **Result**: $(x_1 \vee x_2 \vee z) \wedge (\neg z \vee x_3 \vee x_4)$
- **Preserves**: Original satisfiable *iff* split version satisfiable

:::

# Polyequivalence captures equal difficulty

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid equals >}} **Polyequivalence**: When problems $F$ and
$G$ reduce to each other
- {{< iconify fa6-solid scale-balanced >}} **Equal difficulty**: $F \equiv_P
G$ means same computational hardness
- {{< iconify fa6-solid link >}} **Transitivity**: Polyreductions compose to
create equivalence classes
- {{< iconify fa6-solid layer-group >}} **Complexity classes**: Groups of
equally hard problems
- {{< iconify fa6-solid forward >}} **NP-completeness preview**: Foundation
for next chapter's theory

:::

::: {.fragment .fade style="margin-top: -0.25em; font-size: 0.75em;"}

{{< iconify fa6-solid gears >}} **Polyequivalence "partitions" problems into
difficulty classes**: if solving one problem in the class efficiently solves
all problems in that class, then they form a natural unit of study. This
creates the mathematical structure for NP-completeness!

:::

## Definition of polyequivalence

![](13-polyreductions_19.png)

::: {.fragment style="font-size: 0.85em;"}

- **Definition**: $F \equiv_P G$ if $F \leq_P G$ and $G \leq_P F$
- **Meaning**: Problems are equally hard
- **Examples**: UHC $\equiv_P$ DHC, CircuitSAT $\equiv_P$ SAT $\equiv_P$
3-SAT
- **Transitivity**: If $F \equiv_P G$ and $G \leq_P H$, then $F \equiv_P
H$

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyequivalence creates complexity classes**: problems that are
polyequivalent have the same fundamental difficulty. This is the foundation for
NP-completeness theory in the next chapter! Get ready for some fun!

:::

## Key insights for proofgrammers

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid check-circle >}} **Polyreductions**: Compare
problem difficulty via transformations
- {{< iconify fa6-solid check-circle >}} **Three conditions**: pos→pos,
neg→neg, and polytime
- {{< iconify fa6-solid check-circle >}} **SAT problems**: CircuitSAT,
SAT, and 3-SAT are fundamental
- {{< iconify fa6-solid check-circle >}} **Polyequivalence**: $F \equiv_P
G$ means equal difficulty
- {{< iconify fa6-solid check-circle >}} **Proof technique**: Describe
transformation, verify conditions
- {{< iconify fa6-solid check-circle >}} **Next chapter**: NP-completeness
builds on these ideas!

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

**Polyreductions are the foundation of complexity theory**: they let us prove
that problems are equally hard and establish a hierarchy of difficulty. Next,
we'll use these tools to identify the "hardest" problems in NP!

:::
